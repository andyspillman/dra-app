.\" Automatically generated by Pod::Man 2.12 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Wav 3"
.TH Wav 3 "2006-03-22" "perl v5.8.8" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Audio::Wav \- Modules for reading & writing Microsoft WAV files.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&    # copying a file and adding some cue points to the output file
\&    use Audio::Wav;
\&    my $wav = new Audio::Wav;
\&    my $read = $wav \-> read( 'input.wav' );
\&    my $write = $wav \-> write( 'output.wav', $read \-> details() );
\&    print "input is ", $read \-> length_seconds(), " seconds long\en";
\&
\&    $write \-> set_info( 'software' => 'Audio::Wav' );
\&    my $data;
\&    #read 512 bytes
\&    while ( defined( $data = $read \-> read_raw( 512 ) ) ) {
\&        $write \-> write_raw( $data );
\&    }
\&    my $length = $read \-> length_samples();
\&    my( $third, $half, $twothirds ) = map int( $length / $_ ), ( 3, 2, 1.5 );
\&    my %samp_loop = (
\&        'start' => $third,
\&        'end'   => $twothirds,
\&    );
\&    $write \-> add_sampler_loop( %samp_loop );
\&    $write \-> add_cue( $half, "cue label 1", "cue note 1" );
\&    $write \-> finish();
\&
\&
\&    # splitting a multi\-channel file to seperate mono files (slowly!);
\&    use Audio::Wav;
\&    my $read = $wav \-> read( '4ch.wav' );
\&    my $details = $read \-> details();
\&    my %out_details = map { $_ => $details \-> {$_} } 'bits_sample', 'sample_rate';
\&    $out_details{'channels'} = 1;
\&    my @out_files;
\&    my $in_channels = $details \-> {'channels'};
\&    foreach my $channel ( 1 .. $in_channels ) {
\&        push @out_files, $wav \-> write( 'multi_' . $channel . '.wav', \e%out_details );
\&    }
\&
\&    while ( 1 ) {
\&        my @channels = $read \-> read();
\&        last unless @channels;
\&        foreach my $channel_id ( 0 .. $#channels ) {
\&            $out_files[$channel_id] \-> write( $channels[$channel_id] );
\&        }
\&    }
\&
\&    # not entirely neccessary as finish is done in DESTROY now (if the file hasn't been finished already).
\&    foreach my $write ( @out_files ) {
\&        $write \-> finish();
\&    }
.Ve
.SH "NOTES"
.IX Header "NOTES"
All sample positions are now in sample offsets (unless option '.01compatible' is true).
.PP
There is now *very* basic support for \s-1WAVEFORMATEXTENSIBLE\s0 (in fact it only recognises that the file is in this format).
The key 'wave\-ex' is used in the detail hash to denote this format when reading or writing.
I'd like to do more with this, but don't have any hardware or software to test these files, also don't really have any spare time to do the implementation at present.
.PP
One day I plan to learn enough C to do the sample reading/ writing in \s-1XS\s0, but for the time being it's done using pack/ unpack in Perl and is slow.
Working with the raw format doesn't suffer in this way.
.PP
It's likely that reading/ writing files with bit-depth greater than 16 won't work properly, I need to look at this at some point.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
These modules provide a method of reading & writing uncompressed Microsoft \s-1WAV\s0 files.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.Vb 1
\&    L<Audio::Wav::Read>
\&
\&    L<Audio::Wav::Write>
.Ve
.SH "METHODS"
.IX Header "METHODS"
.Sh "new"
.IX Subsection "new"
Returns a blessed Audio::Wav object.
All the parameters are optional and default to 0
.PP
.Vb 6
\&    my %options = (
\&        '.01compatible'         => 0,
\&        'oldcooledithack'       => 0,
\&        'debug'                 => 0,
\&    );
\&    my $wav = Audio::Wav \-> new( %options );
.Ve
.Sh "write"
.IX Subsection "write"
Returns a blessed Audio::Wav::Write object.
.PP
.Vb 5
\&    my $details = {
\&        'bits_sample'   => 16,
\&        'sample_rate'   => 44100,
\&        'channels'      => 2,
\&    };
\&
\&    my $write = $wav \-> write( 'testout.wav', $details );
.Ve
.PP
See Audio::Wav::Write for methods.
.Sh "read"
.IX Subsection "read"
Returns a blessed Audio::Wav::Read object.
.PP
.Vb 1
\&    my $read = $wav \-> read( 'testout.wav' );
.Ve
.PP
See Audio::Wav::Read for methods.
.Sh "set_error_handler"
.IX Subsection "set_error_handler"
Specifies a subroutine for catching errors.
The subroutine should take a hash as input. The keys in the hash are 'filename', 'message' (error message), and 'warning'.
If no error handler is set, die and warn will be used.
.PP
.Vb 11
\&    sub myErrorHandler {
\&        my( %parameters ) = @_;
\&        if ( $parameters{'warning'} ) {
\&            # This is a non\-critical warning
\&            warn "Warning: $parameters{'filename'}: $parameters{'message'}\en";
\&        } else {
\&            # Critical error!
\&            die "ERROR: $parameters{'filename'}: $parameters{'message'}\en";
\&        }
\&    }
\&    $wav \-> set_error_handler( \e&myErrorHandler );
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
.Vb 2
\&    Nick Peskett (see http://www.peskett.co.uk/ for contact details).
\&    Kurt George Gjerde <kurt.gjerde@media.uib.no>. (0.02\-0.03)
.Ve
