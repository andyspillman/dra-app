#!/usr/bin/perl -w
# ----------------------------------------------------------------------------
# Name:  dra-video
# Desc:  Sends a video project to the dra server and mdss
# Args:  Project folder
#
# Adam Wead
# Jacobs School of Music
# Indiana University
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
#
# Setup libraries and packages
#
# ----------------------------------------------------------------------------

# We have to have an environment variable telling us where the app is
if ( !$ENV{DRA_HOME} ) {
    die "DRA_HOME not set\n";
}

use lib "$ENV{DRA_HOME}/lib";
use DRA;
use strict;
use AppConfig;
use Path::Class;
use IO::CaptureOutput qw(capture qxx qxy);
use Carp;
use Storable;

# ----------------------------------------------------------------------------
#
# Define application-wide variables
#
# ----------------------------------------------------------------------------

my $config = AppConfig->new( {
    ERROR    => \&main::error,
    PEDANTIC => 1,
} );

# Define all video.conf variables
$config->define( "audioDir=s" );
$config->define( "conversionErrorLog=s" );
$config->define( "conversionLog=s" );
$config->define( "copiedLog=s" );
$config->define( "draKey=s" );
$config->define( "draServer=s" );
$config->define( "draUser=s" );
$config->define( "errorLog=s" );
$config->define( "hallList=s" );
$config->define( "logDir=s" );
$config->define( "mdssErrorLog=s" );
$config->define( "mdssLog=s" );
$config->define( "remoteBlock=s" );
$config->define( "rsyncLog=s" );
$config->define( "semester=s" );
$config->define( "sentToBeBurnedLog=s" );
$config->define( "sshOpts=s" );
$config->define( "videoDirs=s" );
$config->define( "videoErrorLog=s" );
$config->define( "videoTransLog=s" );
$config->define( "videoLog=s" );

# Command line switches
$config->define("f!");
$config->define("help!");

# Read in variables from our config file and override any options passed from
# the comand line
my $confFile = Path::Class::File->new( $ENV{DRA_HOME}, "conf", "video.conf" );
if ( !-e $confFile ) {
    die "video.conf config file not found!";
}
$config->file("$confFile");
$config->args();

# Initialize only the variables we'll be using here
my $draServer          = $config->get( "draServer"     );
my $draUser            = $config->get( "draUser"       );
my $draKey             = $config->get( "draKey"        );
my $audioDir           = $config->get( "audioDir"      );
my $semester           = $config->get( "semester"      );
my $remoteBlockList    = $config->get( "remoteBlock"   );
my $remoteErrorLog     = $config->get( "errorLog"      );
my $remoteTransferLog  = $config->get( "copiedLog"     );
my $remoteMdssLog      = $config->get( "mdssLog"       );
my $remoteMdssErrorLog = $config->get( "mdssErrorLog"  );
my $videoLog           = $config->get( "videoLog"      );
my $videoErrorLog      = $config->get( "videoErrorLog" );
my $videoTransLog      = $config->get( "videoTransLog" );
my $logDir             = $config->get( "logDir"        );
my $hallList           = $config->get( "hallList"      );
my $sshOpts            = $config->get( "sshOpts"       );

# Initialize command line switches
my $force        = $config->get("f");

# Show help
if ( $config->get("help") ) {
    main::help();
    exit 0;
}

# Check input
if (! $ARGV[0]) {
    main::error("No folder specified"); 
}
my $projectDir = Path::Class::Dir->new($ARGV[0]);
if (! -d $projectDir) {
    main::error("Specified folder does not exist");
}
            
# Check our local block list
#my $run = DRA::checkBlocks($blockList);
#if ($run) {
#    croak($run);
#}


# ----------------------------------------------------------------------------
#
# Do some stuff
#
# ----------------------------------------------------------------------------

# Build paths to local files and folders
my $localAccessDir   = Path::Class::Dir->new($projectDir, "access" );
my $projectLogDir    = Path::Class::Dir->new($projectDir, "access", "logs" );

my $sshKeyPath       = Path::Class::File->new($ENV{DRA_HOME}, "conf", $draKey);
my $projectLogPath   = Path::Class::File->new($projectLogDir, $videoLog );
my $errorLogPath     = Path::Class::File->new($projectLogDir, $videoErrorLog );
my $videoLogPath     = Path::Class::File->new($logDir, $videoLog);

DRA::logger("dra-video processing $projectDir", $videoLogPath);

# Exit conditions - when the script will stop
unless ($force) {
    # No access directory? This is manually created to indicate the project is
    # ready
    if (! -e $localAccessDir) {
        DRA::logger("No access directory found; exiting.", $videoLogPath);
        exit 0;
    }
    # Process log and no error log means it worked
    if ( (-e $projectLogPath) and (! -e $errorLogPath) ) {
        DRA::logger(
            "Video project was successfully processed at an earlier time",
            $videoLogPath
        );
        exit 0;
    }
}

# Create a log directory
if (! -e $projectLogDir) {
    system("mkdir", $projectLogDir) == 0
        or croak "Failed to created log directory: $!\n";
}

# Delete error log, if it exists and initialize error array
if (-e $errorLogPath) {
    system("rm", $errorLogPath) == 0
        or croak "Failed to remove error log: $!\n";
}
my @errors;

# Check for a well-formed project directory
DRA::logger( "Checking project directory ...", $videoLogPath );
my ( $datedDir, $hallEmail, $varID, $mdssPrefix, $errMsg ) =
  DRA::checkProjectDir( $projectDir, $hallList );
if ($errMsg) {
    push @errors, $errMsg;
}

DRA::logger( "Checking file names ...", $videoLogPath );
# Check project directory contents
my $pderr = DRA::checkVideoDirectoryContents($projectDir, $varID);
if ($pderr) {
    push @errors, $pderr;
}

&main::evaluateErrors;

# Build paths to remote files on DRA server
my $remoteProjectDir = Path::Class::Dir->new($audioDir, $semester, $datedDir);
my $remoteAccessDir  = Path::Class::Dir->new($remoteProjectDir, "access" );
my $remoteLogDir     
    = Path::Class::Dir->new($remoteProjectDir, "access", "logs" );

# Check block list on remote server
my $checkCommand = "ps -ax";
my $runningProcs = main::remoteCommand($checkCommand);
my @blocks = split / /, $remoteBlockList;
my @remoteProcs;
foreach my $block (@blocks) {
    if ($runningProcs =~ /$block/) {
        push @remoteProcs, $block;
    }
}
if (@remoteProcs) {
    my $list = join ", ", @remoteProcs;
    my $message
        = "The following blocking processed were detected on the "
        . "remote system: " . $list . " -- "
        . "Script will terminate now."
        ;
    DRA::logger($message, $videoLogPath);
    exit 0;
}

# Write out list of video files to be included in the marc record
#
# Names of each file will reflect the new names they will have after they are
# renamed later in this script.
DRA::logger("Checking for local video file list", $videoLogPath);
my $listName = $varID . "_MDSSVideoFileNames.txt";
my $listPath = Path::Class::File->new( $projectLogDir, $listName );
if ( (-e $listPath ) and (! $force) ) {
    DRA::logger("...it's there; moving on", $videoLogPath );
}
else {
    DRA::logger(
        "...it's not there; creating video file list", 
        $videoLogPath
    );
    my @videoContents = DRA::readDirectory($projectDir);
    my @videoFiles;
    foreach my $f (@videoContents) {
        unless ($f =~ /^access$/) {
            my $newName = $mdssPrefix . "_" . $f;
            push @videoFiles, $newName;
        }
    }
    my $videoFileList = join "; ", @videoFiles;
    my $list 
        = "Video files stored on MDSS in \"audiopro\" account: "
        . $videoFileList;
    DRA::logger(
        "...writting video file list to local project directory", 
        $videoLogPath
    );
    DRA::writer( $list, $listPath );

}

# Send video filename list
DRA::logger(
    "Checking to see if the video list is on the remote server",
    $videoLogPath
);
my $remoteListFile = Path::Class::File->new($remoteLogDir, $listName);
if ( (main::remoteFileExists($listName)) and (! $force) ) {
    DRA::logger("...it is; moving on", $videoLogPath);
}
else {
    if ($force) {
        DRA::logger("...force option! Sending to server", $videoLogPath);
    }
    else {
        DRA::logger("...it's not; sending list to server", $videoLogPath);
    }
    my $err = DRA::sendSCP(
        {
            user   => $draUser,
            key    => $sshKeyPath,
            opts   => $sshOpts,
            source => $listPath,
            dest   => $remoteListFile,
            host   => $draServer,
        }
    );
    
    if ($err) {
        DRA::logger( 
            "File list copy failed -- see error log",
            $videoLogPath 
        );
        push @errors, $err;
    }
    
    &main::evaluateErrors;
}


# Log in to DRA server and determine status of project
#
# Script will not continue until the project has been completely transferred
# to MDSS.  If there is any error log, the script will stop at this point.
# Once both the Variations and MDSS transfer is complete, this script will
# transfer the additional video files.
DRA::logger("Logging into remote server ...", $videoLogPath);
DRA::logger("Checking project directory: $remoteProjectDir", $videoLogPath);
DRA::logger("...checking logs under remote project directory", $videoLogPath); 
if ((! main::remoteFileExists($remoteMdssLog)) or 
    (main::remoteFileExists($remoteMdssErrorLog)) or
    (! main::remoteFileExists($remoteTransferLog)) or 
    (main::remoteFileExists($remoteErrorLog))) {
     
    my $message
        = "The audio portion of the concert has either not been successfully "
        . "transferred to Variations or MDSS yet."
        ;
    DRA::logger($message, $videoLogPath);
    exit 0;
}

# Okay, we're good to go...
DRA::logger("Remote project is ready for video data", $videoLogPath);
DRA::logger("Copying DVD files to remote DRA server", $videoLogPath);
my @dvdFiles = DRA::readDirectory($projectDir, "img");
foreach my $dvd (@dvdFiles) {
    my $remoteDvdName = $mdssPrefix . "_" . $dvd;
    my $remoteDvd 
        = Path::Class::File->new($remoteProjectDir, "access", $remoteDvdName);
    if (main::remoteFileExists($remoteDvdName) and !$force) {
        my $message = "$dvd has already been transfered";
        DRA::logger($message, $videoLogPath);
    }
    else {

        my $source = Path::Class::File->new($projectDir, $dvd);
        my $err = DRA::sendSCP(
            {
                user   => $draUser,
                key    => $sshKeyPath,
                opts   => $sshOpts,
                source => $source,
                dest   => $remoteDvd,
                host   => $draServer,
            }
        );

        if ($err) {
            DRA::logger( 
                "DVD file copy failed -- see error log",
                $videoLogPath 
            );
            push @errors, $err;
        }

        DRA::logger("Computing md5 sums", $videoLogPath);
        my ($md5, $md5err) = DRA::createMD5($source,$dvd);
        if ($md5err) {
            DRA::logger( 
                "MD5 creation failed -- see error log",
                $videoLogPath 
            );
            push @errors, $md5err;
        }

        DRA::logger("Checking md5 sums for $dvd ...", $videoLogPath);
        my $md5Path = Path::Class::File->new($projectDir, $md5);
        my $md5sum = DRA::getMD5($md5Path);
        my $remoteMd5Command = "md5 -q " . $remoteDvd;
        my $remoteMd5 = main::remoteCommand($remoteMd5Command);
        if ($md5sum eq $remoteMd5) {
            my $message
                = "sums are the same - check passed";
            DRA::logger($message, $videoLogPath);
        }
        else {
            my $message
                = "sums differ - check failed";
            # TODO: need to delete the remote file
            # otherwise the script will continue next time
            DRA::logger($message, $videoLogPath);
            push @errors, $message;
        }
       
    }
}

&main::evaluateErrors;

# Now we send all the files from this video station to MDSS



DRA::logger("dra-video finished.", $videoLogPath);

# end main


# ----------------------------------------------------------------------------
#
# Subroutines
#
# ----------------------------------------------------------------------------


# -------------------------------------------------------------------
# Name: error, help
# Desc: Just an error and help routine...nothing to see here...
#       move along...
# -------------------------------------------------------------------

sub error {
    my $message = shift;

    if ($message) {
        print $message . "\n";
    }
    else {
        print "Invalid option\n";
        &main::help;
    }
    
    exit 1;
}

sub help {
    print "Usage: dra-mdss [-help] [-f] [video.conf options] [project_directory] \n";
}



# -------------------------------------------------------------------
# Name: remoteCommand
# Desc: Runs command on remote system croaking on any error
# -------------------------------------------------------------------

sub remoteCommand {
    
    my $command = shift;

    my ($out, $err) = DRA::sshCommand(
        {
        user    => $draUser,
        sshKey  => $sshKeyPath,
        host    => $draServer,
        command => $command,
        }
    );

    if ($err) {
        croak "Remote command failed.  Error was:\n $err";
    }
    else {
        return $out;
    }

}



# -------------------------------------------------------------------
# Name: remoteQuietCommand
# Desc: Runs command on remote system quietly returning any errors
# -------------------------------------------------------------------

sub remoteQuietCommand {
    
    my $command = shift;

    my ($out, $err) = DRA::sshCommand(
        {
        user    => $draUser,
        sshKey  => $sshKeyPath,
        host    => $draServer,
        command => $command,
        }
    );

    return ($out, $err);

}


# -----------------------------------------------------------------------------
# Name: remoteFileExists
# Desc: Detects presence of file in the project directory of the remote system
#       Returns 0 if file does not exists or the underlying command returns
#       an error.
#       Returns 1 if the file exists, or the underlying command returns
#       success.
# Reqs: Requires remoteProjectDir variable which should be declared earlier in
#       the script.
# Inpt: Name of the file
# Outp: 0 for not found; 1 if the file is found
# -----------------------------------------------------------------------------

sub remoteFileExists {

    my $file = shift;
    my $command = "find $remoteProjectDir -name $file";
    my ($out, $err) = main::remoteQuietCommand($command);

    if ($err) {
        my $message
            = "Remote find command failed - script aborting "
            . "Error was:\n$err";
        DRA::logger($message, $errorLogPath);
        DRA::logger($message, $videoLogPath);
        croak $message;
    }
    else {
        if ($out) {
            return 1;
        }
        else {
            return 0;
        }
    }

}

# -----------------------------------------------------------------------------
# Name: evaliuateErrors
# Desc: Checks the @error array for messages and croaks if there are any
# -----------------------------------------------------------------------------

sub evaluateErrors {

    if ($errors[0]) {
        my $line = join "\n", @errors;
        if ($force) {
            DRA::logger("Errors found - ignoring", $videoLogPath);
            DRA::logger("Errors were: $line", $videoLogPath);
        }
        else {
            DRA::logger("Errors were found - writing to log", $videoLogPath);
            DRA::logger( $line,                               $errorLogPath);
            croak(
                qq{Errors were found with the project directory\n},
                qq{Script will terminate now\n},
            );
        }
    }

}

__END__

=head1 DRA-MDSS

dra-mdss - Transfers projects to IU's mass data storage facility

=head1 VERSION

This documentation refers to dra-mdss version 2.0.

=head1 USAGE

B<dra-mdss [-help] [-f] [dra.conf options] [project_directory]>

=head1 REQUIRED ARGUMENTS

A B<project directory> is required for the script to run. This must be the full
path the directory.  For example:

B<dra-mdss /Volumes/audio/Concerts/2010_fall/20100923vab1234>

=head1 OPTIONS

B<-help> Displays brief synopsis of usage.

B<-f> Force flag.  The project will be transferred to mdss regardless of any errors 
or if the concert was successfully sent at an earlier time.
 
B<dra.conf> Any setting from the dra.conf file may be passed to the script at runtime in the format:

-[variable name] [value]

Example:

B<dra-mdss -email joebob@indiana.edu [directory]>

Will execute the script overriding the email address specified in dra.conf with joebob@indiana.edu

=head1 DESCRIPTION

dra-mdss will take a project folder that had been successfully processed by the dra-transfer
script and send it to the mdss storage facility for archiving. During this processes, files
will be renamed and checksums will be computed and stored along with the original files to
ensure accurate transfers in the future.

The script will continue to process a project directory until there is a successful
outcome.  Once the project has been successfully sent to mdss, any further executions
on that particular project directory will have no effect. Using the force option,
(-f) will override this and re-send the project to mdss.

=head1 DIAGNOSTICS

Upon successful execution, the dra-mdss with exit with no output. Any fatal
error will be written to standard output and the application will exit immediately.
Messages are written to the application's own log file found in the application
log directory, as well as a separate log file found in the project's log
directory in the access folder.

In the case of errors written to standard out, the error will appear on the
command line shell or will be collected by the calling script, usually
dra-run. The presence of any fatal error will cause the script to write an
error log to the project log directory found in the access folder of the
project. The presence of this file will mean dra-mdss will run again when
called either directly or by dra-run.

=head1 CONFIGURATION AND ENVIRONMENT

A properly configured dra.conf file should be sufficient for dra-mdss
script to run.

The DRA_HOME environment variable is required and can be set on a per-user basis
or at execution time.

=head1 DEPENDENCIES

HTAR and HSI are required to send the files to MDSS.  These applications are
available through IU's mass datastore service.  See http://kb.iu.edu/data/auvo.html
for the latest client builds available.

You will also need to create kerberos keytab files to enable automate access to the mdss account.
For more information on creating keytab files, see http://kb.iu.edu/data/avdb.html.

=head1 AUTHOR

Adam Wead     awead@indiana.edu, amsterdamos@gmail.com

Travis Gregg  

=head1 LICENCE AND COPYRIGHT

Copyright 2010, the Trustees of Indiana University.

=cut

